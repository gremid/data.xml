;; Copyright (c) Chris Houser, April 2008. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns gremid.data.xml.zip
  "System for filtering trees and nodes generated by
  zip.clj in general, and xml trees in particular."
  (:require [clojure.zip :as zip]))

(defn right-locs
  "Returns a lazy sequence of locations to the right of loc, starting with loc."
  [loc]
  (lazy-seq (when loc (cons loc (right-locs (zip/right loc))))))

(defn left-locs
  "Returns a lazy sequence of locations to the left of loc, starting with loc."
  [loc]
  (lazy-seq (when loc (cons loc (left-locs (zip/left loc))))))

(defn leftmost?
  "Returns true if there are no more nodes to the left of location loc."
  [loc]
  (nil? (zip/left loc)))

(defn rightmost?
  "Returns true if there are no more nodes to the right of location loc."
  [loc]
  (nil? (zip/right loc)))

(defn children
  "Returns a lazy sequence of all immediate children of location loc,
  left-to-right."
  [loc]
  (when (and loc (zip/branch? loc)) (right-locs (zip/down loc))))

(defn descendants'
  "Returns a lazy sequence of all descendants of location loc, in
  depth-first order, left-to-right, starting with loc."
  [loc]
  (lazy-seq (when loc (cons loc (mapcat descendants' (children loc))))))

(defn subtree
  "All descendants of loc, excluding loc itself."
  [loc]
  (seq (rest (descendants' loc))))

(defn ancestors'
  "Returns a lazy sequence of all ancestors of location loc, starting
  with loc and proceeding to loc's parent node and on through to the
  root of the tree."
  [loc] (lazy-seq (when loc (cons loc (ancestors' (zip/up loc))))))

(defn ancestry
  "All ancestors of loc, excluding loc itself."
  [loc]
  (seq (rest (ancestors' loc))))

(defn prev-locs
  "Returns a lazy sequence of locations preceding and starting with loc."
  [loc]
  (lazy-seq (when loc (cons loc (prev-locs (zip/prev loc))))))

(defn next-locs
  "Returns a lazy sequence of locations following and starting with loc."
  [loc]
  (lazy-seq (when (and loc (not (zip/end? loc)))
              (cons loc (next-locs (zip/next loc))))))

(defn zip-node?
  [v]
  (some-> v meta :zip/branch?))

(defn fixup-apply
  "Calls (pred loc), and then converts the result to the 'appropriate'
  sequence."
  [pred loc]
  (let [rtn (pred loc)]
    (cond
      (zip-node? rtn)   (list rtn)
      (= rtn true)      (list loc)
      (= rtn false)     nil
      (nil? rtn)        nil
      (sequential? rtn) rtn
      :else             (list rtn))))

(defn mapcat-chain
  [loc preds mkpred]
  (reduce
   (fn [prevseq expr]
     (mapcat #(fixup-apply (or (mkpred expr) expr) %) prevseq))
   (list loc)
   preds))


(declare xml->)

(defn attr
  "Returns the xml attribute named attrname, of the xml node at location loc."
  ([attrname]
   (fn [loc] (attr loc attrname)))
  ([loc attrname]
   (when (zip/branch? loc)
     (-> loc zip/node :attrs attrname))))

(defn attr=
  "Returns a query predicate that matches a node when it has an
  attribute named attrname whose value is attrval."
  [attrname attrval]
  (fn [loc] (= attrval (attr loc attrname))))

(defn tag=
  "Returns a query predicate that matches a node when its is a tag
  named tagname."
  [tagname]
  (fn [loc] (when (= tagname (:tag (zip/node loc))) (list loc))))

(defn child-tag=
  [tagname]
  (fn [loc]
    (filter #(and (zip/branch? %) (= tagname (:tag (zip/node %))))
            (some-> loc children))))

(defn text
  "Returns the textual contents of the given location, similar to XPath's
  value-of()."
  [loc]
  (apply str (xml-> loc descendants' zip/node string?)))

(defn text=
  "Returns a query predicate that matches a node when its textual
  content equals s."
  [s]
  (fn [loc] (= (text loc) s)))

(defn seq-test
  "Returns a query predicate that matches a node when its xml content matches the
  query expressions given."
  [preds]
  (fn [loc] (and (seq (apply xml-> loc preds)) (list loc))))

(defn xml->
  "The loc is passed to the first predicate. If the predicate returns a
  collection, each value of the collection is passed to the next predicate. If
  it returns a location, the location is passed to the next predicate. If it
  returns true, the input location is passed to the next predicate. If it
  returns false or nil, the next predicate is not called.

  This process is repeated, passing the processed results of each predicate to
  the next predicate. xml-> returns the final sequence. The entire chain is
  evaluated lazily.

  There are also special predicates: keywords are converted to child-tag=,
  strings to text=, and vectors to sub-queries that return true if they match."
  [loc & preds]
  (mapcat-chain loc preds
                #(cond (keyword? %) (child-tag= %)
                       (string?  %) (text= %)
                       (vector?  %) (seq-test %))))

(defn xml1->
  "Returns the first item from loc based on the query predicates given. See xml->"
  [loc & preds]
  (first (apply xml-> loc preds)))
